<?php&#10&#10namespace Drupal\par_forms\Plugin\EntityReferenceSelection;&#10&#10use Drupal\Component\Utility\Html;&#10use Drupal\Core\Database\Query\AlterableInterface;&#10use Drupal\Core\Entity\EntityFieldManagerInterface;&#10use Drupal\Core\Entity\EntityReferenceSelection\SelectionPluginBase;&#10use Drupal\Core\Entity\EntityReferenceSelection\SelectionWithAutocreateInterface;&#10use Drupal\Core\Entity\EntityRepositoryInterface;&#10use Drupal\Core\Entity\EntityTypeBundleInfoInterface;&#10use Drupal\Core\Entity\EntityTypeManagerInterface;&#10use Drupal\Core\Entity\Exception\UnsupportedEntityTypeDefinitionException;&#10use Drupal\Core\Entity\FieldableEntityInterface;&#10use Drupal\Core\Extension\ModuleHandlerInterface;&#10use Drupal\Core\Field\Plugin\Field\FieldType\EntityReferenceItem;&#10use Drupal\Core\Form\FormStateInterface;&#10use Drupal\Core\Plugin\ContainerFactoryPluginInterface;&#10use Drupal\Core\Session\AccountInterface;&#10use Drupal\par_data\ParDataManagerInterface;&#10use Drupal\user\EntityOwnerInterface;&#10use Symfony\Component\DependencyInjection\ContainerInterface;&#10use Drupal\Core\Entity\Plugin\EntityReferenceSelection\DefaultSelection;&#10&#10/**&#10 * PAR plugin implementation of the Entity Reference Selection plugin.&#10 *&#10 * Also serves as a base class for specific types of Entity Reference&#10 * Selection plugins.&#10 *&#10 * @see \Drupal\Core\Entity\EntityReferenceSelection\SelectionPluginManager&#10 * @see \Drupal\Core\Entity\Annotation\EntityReferenceSelection&#10 * @see \Drupal\Core\Entity\EntityReferenceSelection\SelectionInterface&#10 * @see \Drupal\Core\Entity\Plugin\Derivative\DefaultSelectionDeriver&#10 * @see plugin_api&#10 *&#10 * @EntityReferenceSelection(&#10 *   id = "par",&#10 *   label = @Translation("PAR"),&#10 *   group = "default",&#10 *   weight = 0,&#10 *   deriver = "Drupal\Core\Entity\Plugin\Derivative\DefaultSelectionDeriver"&#10 * )&#10 */&#10class ParDataSelection extends DefaultSelection implements ContainerFactoryPluginInterface, SelectionWithAutocreateInterface {&#10&#10  /**&#10   * Get the par data manager.&#10   *&#10   * @return ParDataManagerInterface&#10   */&#10  public function getParDataManager(): ParDataManagerInterface {&#10    return \Drupal::service('par_data.manager');&#10  }&#10&#10  /**&#10   * Builds an EntityQuery to get referenceable entities.&#10   *&#10   * @param string|null $match&#10   *   (Optional) Text to match the label against. Defaults to NULL.&#10   * @param string $match_operator&#10   *   (Optional) The operation the matching should be done with. Defaults&#10   *   to "CONTAINS".&#10   *&#10   * @return \Drupal\Core\Entity\Query\QueryInterface&#10   *   The EntityQuery object with the basic conditions and sorting applied to&#10   *   it.&#10   */&#10  protected function buildEntityQuery($match = NULL, $match_operator = 'CONTAINS') {&#10    $configuration = $this->getConfiguration();&#10    $target_type = $configuration['target_type'];&#10    $entity_type = $this->entityTypeManager->getDefinition($target_type);&#10&#10    $query = $this->entityTypeManager->getStorage($target_type)->getQuery();&#10    $query->accessCheck(TRUE);&#10&#10    // If 'target_bundles' is NULL, all bundles are referenceable, no further&#10    // conditions are needed.&#10    if (is_array($configuration['target_bundles'])) {&#10      // If 'target_bundles' is an empty array, no bundle is referenceable,&#10      // force the query to never return anything and bail out early.&#10      if ($configuration['target_bundles'] === []) {&#10        $query->condition($entity_type->getKey('id'), NULL, '=');&#10        return $query;&#10      }&#10      elseif ($entity_type->hasKey('bundle')) {&#10        $query->condition($entity_type->getKey('bundle'), $configuration['target_bundles'], 'IN');&#10      }&#10      else {&#10        // If 'target_bundle' is set and entity type doesn't support bundles&#10        // something is wrong.&#10        $message = \sprintf(&#10          "Trying to use non-empty 'target_bundle' configuration on entity type '%s' without bundle support.",&#10          $entity_type->id(),&#10        );&#10        throw new UnsupportedEntityTypeDefinitionException($message);&#10      }&#10    }&#10&#10    $par_data_authority_type = $this->getParDataManager()->getParBundleEntity('par_data_authority');&#10    $label_fields = $par_data_authority_type->getLabelFields();&#10    if (isset($match) && !empty($label_fields)) {&#10      // Create the condition group.&#10      $label_group = $query->orConditionGroup();&#10&#10      // Add each condition.&#10      foreach ($label_fields as $field) {&#10        $label_group->condition($field, $match, $match_operator);&#10      }&#10&#10      // Add the condition group.&#10      $query->condition($label_group);&#10    }&#10&#10    // Add entity-access tag.&#10    $query->addTag($target_type . '_access');&#10&#10    // Add the Selection handler for system_query_entity_reference_alter().&#10    $query->addTag('entity_reference');&#10    $query->addMetaData('entity_reference_selection_handler', $this);&#10&#10    // Add the sort option.&#10    if ($configuration['sort']['field'] !== '_none') {&#10      $query->sort($configuration['sort']['field'], $configuration['sort']['direction']);&#10    }&#10&#10    return $query;&#10  }&#10&#10}&#10